<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style>
		html,
		body {
			margin: 0;
			padding: 0;
			height: 100%;	
		}
		canvas {
			display: block;
		}
	</style>
</head>
<body onload="draw()">
	
</body>
</html>
<script src="bulid/three.js"></script>
<script src="examples/js/controls/OrbitControls.js"></script>
<script src="examples/js/libs/dat.gui.min.js"></script>
<script src="examples/js/libs/stats.min.js"></script>
<script>
	var renderer;
	function initRender () {
		// 磨合锯齿，图像更贴合现实
		renderer = new THREE.WebGLRenderer({antialias: true});
		renderer.setSize(window.innerWidth, window.innerHeight);
		// 接收阴影
		renderer.shadowMap.enabled = false;
		// 默认没有设置这个会， 设置了更清晰
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;
		document.body.appendChild(renderer.domElement);
		// 设置渲染器的步骤：
		// 1. new一个renderer对象(CanvasRenderer, WebGLRenderer)
		// 2. 设置渲染器的大小，型号，setSize()
		// 3. 如果需要阴影， 要设置renderer接收阴影
		// 4. 在document里面添加这个渲染元素(renderer.domElement)
	}

	var camera;
	function initCamera () {
		camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
		// 1.  fov 相机视椎体垂直视角(我理解的是，在现实生活中我们肉眼所能看到的视野范围)
		// 2. aspect 相机视椎体的宽高比， 其实就是图像屏幕的宽高比
		// 3. near 相机近剪裁面
		// 4. far 相机远剪裁面
		camera.position.set(0, 40, 100);
		camera.lookAt(new THREE.Vector3(0, 0, 0));
		// 相机的设置
		// 1. 先new camera 对象(正交式相机 --- OrthographicCamera， 透视式相机 --- PerspectiveCamera)
		// 2. 设置相机在场景中的位置 
		// 3. 设置相机的朝向，向哪看
	}

	var scene;
	function initScene () {
		// 场景渲染
		scene = new THREE.Scene();
	}

	var gui;
	function initGui () {
		// dat.gui简化实验流程： 可以方便的调节各个属性值，观察效果
		// 先定制gui的默认范围
		gui = {
            ambientLight:"#111111", //环境光源
            pointLight:"#ffffff", //点光源
            lightY: 30, //灯光y轴的位置
            cubeX: 5, //立方体的x轴位置
            cubeY: 5, //立方体的x轴位置
            cubeZ: -5 //立方体的z轴的位置
        };
        // 1. new 一个dat.GUI对象
        var datGui = new dat.GUI();
        //将设置属性添加到gui当中，gui.add(对象，属性，最小值，最大值）
        // color属性的设置
        datGui.addColor(gui,"ambientLight").onChange(function (e) {
            ambientLight.color = new THREE.Color(e);
        });
        datGui.addColor(gui,"pointLight").onChange(function (e) {
            pointLight.color = new THREE.Color(e);
        });
        // 位置， 大小的设置
        datGui.add(gui, "lightY", 0, 100);
        datGui.add(gui, "cubeX", -30, 30);
        datGui.add(gui, "cubeY", -30, 30);
        datGui.add(gui, "cubeZ", -30, 30);
	}
	// 光的添加
	var ambientLight, pointLight;
	function initLight () {
		// 1. new 需要的光 (一般需要环境光， 平行光相结合，视觉效果更好)
		ambientLight = new THREE.AmbientLight('#111111');
		pointLight = new THREE.PointLight('#ffffff');
		// 2. 创建完光的对象，要在场景中添加
		scene.add(ambientLight);
		// 环境光不需要照射位置，因为场景中导出都是环境光
		// 3. 设置平行光的照射位置
		pointLight.position.set(15, 30, 10);
		// 4. 设置光照后需不需要阴影
		pointLight.castShadow = true;
		scene.add(pointLight);
	}
	var cube;
	function initModel () {
		// 创建几何头体
		// helper 几何体的辅助工具
		 var helper = new THREE.AxisHelper(10);
        scene.add(helper);

        // 创建一个立方体
        //    v6----- v5
        //   /|      /|
        //  v1------v0|
        //  | |     | |
        //  | |v7---|-|v4
        //  |/      |/
        //  v2------v3

        //立方体
        // 1. new 一个几何体，首先要new一个几何模型(就是这个几何体的骨架，就像房子的墙体，人体的骨头)
        // 2. 还要材质皮肤，(房子也需要粉刷， 人也要穿衣服，需要装饰才能够更生动，更丰富)
        // 3. 最后要在Mesh模型中添加这个几何模型，和这个皮肤材质，然后mesh就会把这两者结合起来呈现出一个完美的几何体
        var cubeGeometry = new THREE.CubeGeometry(10,10,10);

        var cubeMaterial = new THREE.MeshLambertMaterial({color: 0x00ffff});

        cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        // 4. 设置几何体的初始位置
        cube.position.x = 5;
        cube.position.y = 5;
        cube.position.z = -5;
        // 5. 再加一些附加条件（例如有没有阴影）
        //告诉立方体需要投射阴影
        cube.castShadow = true;
        // 6. 最后要在场景中添加这个几何体，然后才能看到
        scene.add(cube);

        //底部平面
        // 1. 平面对象， 场景中都有模拟地面的场景
        // 2. 模拟平面也需要几何模型， 几何材质
        // 3. 平面是二维的所以只有两个坐标
        var planeGeometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);
        // 四个参数
        // 1、 沿X轴的宽度
        // 2、 沿Y轴的宽度
        // 3、 可选参数，x方向的分段数，缺省为1
        // 4、 可选参数，y方向的分段数，缺省为1
        var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff, side: THREE.DoubleSide});
        // 

        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        // 改变平面的rotation
        plane.rotation.x = -0.5 * Math.PI;
        plane.position.y = -0;
        plane.position.x = -0;
        plane.position.z = -0;

        //告诉底部平面需要接收阴影
        plane.receiveShadow = true;

        scene.add(plane);
	}
	// 初始化性能插件
	var stats
	function initStats () {
		stats = new Stats();
		document.body.appendChild(stats.dom)
	}

	// 用户交互插件的使用 鼠标左键按住旋转，右键按住平移，滚轮缩放
	var controls
	function initControls () {
		controls = new THREE.OrbitControls(camera, renderer.domElement);

        // 如果使用animate方法时，将此函数删除
        //controls.addEventListener( 'change', render );
        // 使动画循环使用时阻尼或自转 意思是否有惯性
        controls.enableDamping = true;
        //动态阻尼系数 就是鼠标拖拽旋转灵敏度
        //controls.dampingFactor = 0.25;
        //是否可以缩放
        controls.enableZoom = true;
        //是否自动旋转
        controls.autoRotate = false;
        //设置相机距离原点的最远距离
        controls.minDistance = 50;
        //设置相机距离原点的最远距离
        controls.maxDistance = 200;
        //是否开启右键拖拽
        controls.enablePan = true;
	}

	function render () {
		renderer.render(scene, camera);
	}

	// 窗口变动触发的函数
	function onWindowResize () {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatirx();
		render();
		renderer.setSize(window.innerWidth, window.innerHeight);
	}
	// 动画

	function animate () {
		// 更新控制器
		render();
		// 更新性能插件
		stats.update();
		// 更新相关位置
		pointLight.position.y = gui.lightY;
		cube.position.x = gui.cubeX;
		cube.position.y = gui.cubeY;
		cube.position.z = gui.cubeZ;
		controls.update();
		requestAnimationFrame(animate);

	}
	function draw () {
		
        initRender();
        initScene();
        initCamera();
        initLight();
        initModel();
        initControls();
        initStats();
        initGui();
        // three 加载渲染器， 场景， 相机，必须在其他对象之前，不然会报错，不能加载成功，别的对象要引用到这三个模块

        animate();
        window.onresize = onWindowResize;
	}

</script>